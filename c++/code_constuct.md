
## c++程序构建


## 采用cmake方式
cmake构建cpp工程，需要编写cmakeList.txt,如下是一个例子
```cmake
# 项目信息
PROJECT(image12306 C CXX)
# Cmake最低版本要求
CMAKE_MINIMUM_REQUIRED(VERSION 3.5.1)

#设置cmake的一些参数
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fstack-protector \
    --param=ssp-buffer-size=4 -pthread \
    -fno-strict-aliasing -Wall -Wextra -Wno-unused-parameter \
    -Wno-missing-field-initializers -pipe -fPIC \
    -fno-threadsafe-statics \
    -fvisibility-inlines-hidden -std=gnu++11 \
    -m64 -march=x86-64")

set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -O0 -g \
    -DCOMPONENT_BUILD -DDYNAMIC_ANNOTATIONS_ENABLED=1 \
    -D_DEBUG")

set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 \
    -DDYNAMIC_ANNOTATIONS_ENABLED=0 -DNDEBUG -DNVALGRIND \
    -fvisibility=hidden")

set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} \
    -Wl,-z,now -Wl,-z,relro -Wl,--fatal-warnings -Wl,-z,defs -pthread \
    -Wl,-z,noexecstack -fPIC -fuse-ld=gold -m64 -Wl,--disable-new-dtags \
    -Wl,--detect-odr-violations -Wl,--icf=all")

#set(INC_DIR ${CMAKE_SOURCE_DIR}/include)
#set(LINK_DIR ${CMAKE_SOURCE_DIR}/lib)
include_directories(deps/opencv/include ./src)
link_directories(deps/opencv/lib)

# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)

# 添加 src 子目录
add_subdirectory(src)

#指定生成目标p2pDemo
add_executable(image12306Demo ${DIR_SRCS})
#链接第三方库
target_link_libraries(image12306Demo wx_image_util)
```

### cmake方式构建可gdb调试程序
对于一般采用cmake构建的文件，在工程文件夹下执行以下命令
```bash
mkdir build && cd build
//构建cmake文件
cmake ..
//编译
make
```
- 构建可调式的程序
cmakelist.txt中做如下设置
主要是 加上了 ```-g``` 参数
```cmake
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -O0 -g \
    -DCOMPONENT_BUILD -DDYNAMIC_ANNOTATIONS_ENABLED=1 \
    -D_DEBUG")

set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 \
    -DDYNAMIC_ANNOTATIONS_ENABLED=0 -DNDEBUG -DNVALGRIND \
    -fvisibility=hidden")
```
然后生成makefile文件的时候做如下设置,当前编译为debug版本
-DCMAKE_BUILD_TYPE=Debug
```bash
cmake -DCMAKE_BUILD_TYPE=Debug ..
```

## gdb调试
设置可以生成core dump文件
```bash
root@linuxkit-025000000001:/home/cxy/work# ulimit -c
0
root@linuxkit-025000000001:/home/cxy/work# ulimit -c unlimited
root@linuxkit-025000000001:/home/cxy/work# ulimit -c
unlimited
```

进入gdb
gdb <可执行文件> <coredump文件>
```gdb
root@linuxkit-025000000001:/home/cxy/work/c++/code/image12306/build# gdb image12306Demo core
GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from image12306Demo...done.
[New LWP 376]
[New LWP 378]
[New LWP 379]
[New LWP 377]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./image12306Demo'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  strtok () at ../sysdeps/x86_64/strtok.S:186
186	../sysdeps/x86_64/strtok.S: No such file or directory.
[Current thread is 1 (Thread 0x7f162c5aa740 (LWP 376))]
(gdb) bt
#0  strtok () at ../sysdeps/x86_64/strtok.S:186
#1  0x00000000004038e3 in getFileName (str=0x405c08 "/home/cxy/work/project/12306/test_pics/multi_test/11482_70861_1562502181280.jpg") at /home/cxy/work/c++/code/image12306/test.cc:69
#2  0x0000000000404575 in testGetFile () at /home/cxy/work/c++/code/image12306/test.cc:253
#3  0x00000000004045f1 in main (argc=1, argv=0x7ffdb6c50098) at /home/cxy/work/c++/code/image12306/test.cc:263
(gdb) b test.cc:250
Breakpoint 1 at 0x404539: file /home/cxy/work/c++/code/image12306/test.cc, line 250.
(gdb) r
Starting program: /home/cxy/work/c++/code/image12306/build/image12306Demo
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7fffed32b700 (LWP 387)]
[New Thread 0x7fffecb2a700 (LWP 388)]
[New Thread 0x7fffea329700 (LWP 389)]

Thread 1 "image12306Demo" hit Breakpoint 1, testGetFile () at /home/cxy/work/c++/code/image12306/test.cc:250
250	  int file_len = sizeof(file_list) / sizeof(file_list[0]);
(gdb) n
251	  for (int i = 0; i < file_len; ++i) {
(gdb) n
252	    char *file = file_list[i];
(gdb) p *file
Cannot access memory at address 0x0
(gdb) p file
$1 = 0x0
(gdb)
```


## Clion 利用远程docker debug
c++开发来说，mac原生支持的不是很好，最终还是选择linux的环境最靠谱，好在clion提供了远程连接docker，
然后在docker中进行编译，调试；其主要就是利用ssh进入docker，然后将本地代码同步到远程docker中，进行编译和调试

### docker准备
准备好一个ubuntu的docker，docker启动时制定好ssh端口，
比如我这里 
```
//即将宿主机上的8022端口映射到docker中的22端口
-p 8022:22
``` 
 进入docker自后，执行以下命令:
 ```
apt-get update && apt-get install -y openssh-server
mkdir /var/run/sshd
echo 'root:THE_PASSWORD_YOU_CREATED' | chpasswd
sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config

//SSH login fix. Otherwise user is kicked off after login
sed 's@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd

echo "export VISIBLE=now" >> /etc/profile

//最后启动sshd 守护进程
/usr/sbin/sshd
 ```

验证docker是否准备完成
在其他地方 ssh -p 8022 root@docker-ip
可以连接上去，说明docker配置完成



### Clion准备
[参考这里](https://github.com/shuhaoliu/docker-clion-dev)

**注意：为了确保clion连接远程docker后，load cmake不出错，
clion的这边机器和 docker中都需要安装 rsync**

clion端配置,需要修改upload到docker的file保持权限一致：
- Build,Execution,Deployment->Deployment->option:
    - Preserve original file permissions(SFTP only) 勾选  Yes







