[TOC]

# 设计模式

## 单例模式
进程中只存在一个实例
### 优点:
确保进程中只有一个实例存在
能节省资源,避免频繁的创建和销毁对象，避免共享资源的多重占用
对象实例化过程自己控制，伸缩性比较好
### 缺点:
单例职责过重，违反单一原则
### 应用场景:
需要频繁创建和销毁的对象
创建对象时耗时过多或者耗资源过多，但又经常用到的对象

## 建造者模式:
[参考](https://blog.csdn.net/jason0539/article/details/44992733)
将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
### 角色
在这样的设计模式中，有以下几个角色：
1、Builder：为创建一个产品对象的各个部件指定抽象接口，即定义产品的有哪些部件，。
2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，并提供一个检索产品的接口。
3、Director：构造一个使用Builder接口的对象，指导构建过程。
4、Product：表示被构造的复杂对象。由很多部件构成，ConcreteBuilder创建该产品，并为该产品构建所有具体的部件

- 简化版本:
通常将Director和 Builder,ConcreteBuilder合为一个builder类，builder类中直接构建Product
StringBuilder

### 优点:
1、更好的复用性，生成器模式很好的实现构造算法和具体产品实现的分离
2、具体的建造者类之间是相互独立的，容易扩展。
3、可以很容易的改变产品的内部表示
### 缺点:
1、产生多余的Build对象以及Dirextor类，消耗内存
2、对象的构造过程暴露(因为builder中对产品构建的抽象暴露)
### 应用场景:
构造产品的算法比较复杂，且构造算法应该独立与产品的组成部分以及装配他们的方式，
产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能
当构造一个对象需要很多参数或者参数的个数和类型不固定的情况下

## 工厂模式
[参考](https://juejin.im/entry/58f5e080b123db2fa2b3c4c6)
### 简单工厂模式
定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口
#### 适用场景
首先由于只有一个工厂类，工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。总结一下适用场景：
1. 需要创建的对象较少。
2. 客户端不关心对象的创建过程

### 工厂方法模式
相对于简单工厂模式，工厂方法模式根据不同的产品，定义不同的工厂，不同的工厂负责生产相对应的产品
#### 适用场景:
客户端不需要知道它所创建的对象的类,只用了解哪个工厂

### 抽象工厂模式
有多个工厂，每个工厂中生产多种不同的产品
- 角色
AbstractFactory（抽象工厂）：声明了一组用于创建对象的方法，注意是一组。
ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建对象的方法，生成一组具体对象。
AbstractProduct（抽象产品）：它为每种对象声明接口，在其中声明了对象所具有的业务方法。
ConcreteProduct（具体产品）：它定义具体工厂生产的具体对象



## 适配器模式:
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作；

- 角色:
  - Source：需要被适配的类、接口、对象，即Datas。
  - Destination：需要得到的类，Source通过适配得到的类对象，也就是我们期待得到的借口。
  - Adapter：适配器类，协调Source和Destination，使两者能够协同工作

可以说Source的存在形式决定了适配器的名字，
类适配器就是继承Source类，
对象适配器就是持有Source类，
接口适配器就是实现Source接口

### 优点:
1、能提高类的透明性和复用，现有的类复用但不需要改变。
2、目标类和适配器类解耦，提高程序的扩展性。
3、在很多业务场景中符合开闭原则。
### 缺点:
代码的可阅读性会有所下降

### 应用场景:
以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同

## 代理模式:
代理模式就是为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不合适或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用
### 优点:
代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
代理对象可以扩展目标对象的功能；
代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；

### 缺点:
在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
增加了系统的复杂度；

### 应用场景:

## 观察者模式:
定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新
### 优点:
1.因为广播者和观察者代码之间是低耦合的，比较灵活，弹性可扩展性比较高(后续 可以动态的添加新的观察者，而广播者几乎不受影响)
### 缺点:
1.比如需要通知的观察者太多，完整的一个流程下来就可能效率比较低，比较浪费时间
2.如果在观察者和广播者之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
### 应用场景:
1、 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
2、 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节

## 策略模式:
策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代，使算法本身和使用算法的客户端分割开来，相互独立。（遵循开闭原则，易于维护拓展，降低耦合）
### 优点:
1）良好的扩展性。增加一种策略，只要实现接口，写上具体逻辑就可以了。当旧策略不需要时，直接剔除就行。
2）良好的封装性。策略的入口封装在Context封装类中，客户端只要知道使用哪种策略就传哪种策略对象就可以了。
3）避免了像简单工厂模式这样的多重条件判断
### 缺点:
1）客户端必须了解策略组的各个策略，并且决定使用哪一个策略，也就是各个策略需要暴露给客户端。
2）如果策略增多，策略类的数量就会增加

### 应用场景:




